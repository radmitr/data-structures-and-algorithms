package datastructures.heaps;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * ------------------------------------------------------------------------------------------------
 * Бинарная куча
 * ------------------------------------------------------------------------------------------------
 * Куча определение
 *
 * Куча (heap) — разновидность дерева (и как следствие разновидность графа). Отличительной
 * особенностью является наличие выделенной вершины (узла) — вершина кучи. Упорядочивание,
 * которое относит кучу к деревьям, следующее - ключ дочернего узла не больше ключа родительского
 * узла. Это приводит к тому, что в вершине кучи всегда расположен элемент с максимальным ключом.
 * ------------------------------------------------------------------------------------------------
 * Поддерживаемые операции
 *
 * Кучи обычно поддерживают следующие операции:
 *   ● Добавление нового узла в кучу
 *   ● Удаление элемента из кучи
 *   ● Найти узел с максимальным значением ключа
 * ------------------------------------------------------------------------------------------------
 * Бинарная куча
 *
 * Бинарная, двоичная куча (пирамида) одна из наиболее часто используемых видов кучи.
 * Отличительными особенностями бинарной кучи являются:
 *   ● У каждого узла не более 2-х дочерних узлов
 *   ● Все уровни дерева (а куча разновидность дерева) заполнены полностью. Исключение
 *     составляет последний уровень, он может быть заполнен не полностью, в этом случае
 *     заполнение обязательно должно идти слева направо
 *   ● Глубина всех листьев отличается максимум на один слой.
 * ------------------------------------------------------------------------------------------------
 * Добавление элемента в кучу
 *
 * Добавляется элемент всегда на первое незаполненное место слоя. При этом может нарушиться
 * свойство бинарной кучи. В таком случае нужно менять значение с родительским узлом до тех пор,
 * пока свойство кучи не будет восстановлено. Такой процесс называется просеиванием вверх.
 * ------------------------------------------------------------------------------------------------
 * Получение максимального элемента с удалением
 *
 * Для удаления максимального элемента, заменяют его последним значением на последнем
 * уровне. Если условие бинарной кучи нарушается, то проводим обмен с максимальным дочерним
 * элементом, до восстановления условий кучи. Такой процесс восстановления свойств кучи называется
 * просеиванием вниз.
 * ------------------------------------------------------------------------------------------------
 * Одновременная вставка и удаление максимального элемента
 *
 * При одновременной вставке и удалении максимального элемента наиболее оптимальным
 * является замена максимального элемента на вставляемый. Если после этого свойства бинарной кучи
 * не соблюдены, то выполняется просеивание вниз.
 * ------------------------------------------------------------------------------------------------
 * Удаление произвольного узла
 *
 * Удаление произвольного узла производится следующим образом — удаляемый узел
 * заменяется на последний узел последнего слоя. Если после замены произошло нарушение свойств
 * бинарной кучи, то применить просеивание вниз.
 * ------------------------------------------------------------------------------------------------
 * Изменение ключа узла
 *
 * При замене значения ключа для узла, нужно заменить значение ключа на новое. Если новый
 * ключ больше родительского, то выполнять просеивание вверх. Если новый ключ меньше дочернего
 * узла, то выполнить просеивание вниз.
 * ================================================================================================
 * Наиболее простая реализация бинарной кучи
 *
 * Наиболее простой и популярной реализацией бинарной кучи является реализация на основе
 * массива (списка). Корневой узел всегда располагается на нулевом индексе элементом. Индексы
 * потомков любого элемента рассчитываются как [2i+1] и [2i+2].
 * ------------------------------------------------------------------------------------------------
 * Добавление элемента
 *
 * При добавлении элемента стоит хранить указатель на последний добавленный элемент. Этот
 * элемент будет последним элементом последнего слоя. Для вычисления индекса родительского узла
 * использовать выражение [i-1]/2.
 * ------------------------------------------------------------------------------------------------
 * Получение максимального элемента с удалением
 *
 * Для удаления максимального элемента, заменяют значение на нулевом индексе значением
 * последнего элемента. После этого выполняют просеивание вниз для этого элемента. Для этого
 * выполняют обмен этого элемента с элементами на индексах [2i+1], [2i+2] (обмен с тем элементом,
 * что больше).
 * ------------------------------------------------------------------------------------------------
 * Поиск элемента по ключу
 *
 * Поиск узла по ключу реализуется с помощью обычного линейного поиска элемента в массиве.
 * ------------------------------------------------------------------------------------------------
 * Восстановление свойств кучи
 *
 * Для восстановления свойств кучи (например, узел с ключом 2 стоит не на своем месте) нужно:
 * 1) Сравнить значение этого узла с родительским. Если значение узла больше родительского, то
 *    применяют просеивание вверх (индекс родителя [(i-1)/2] ).
 * 2) Сравнить значение этого узла с дочерними. Если значение узла меньше, то применяют
 *    просеивание вниз. Обмен с большим из дочерних узлов. Индексы дочерних элементов [2*i + 1],
 *    [2*i + 2]
 * ------------------------------------------------------------------------------------------------
 * Удаление произвольного узла
 *
 * Удаление произвольного узла сводится к замене этого узла на последний. После чего идет
 * восстановление свойств кучи.
 * ------------------------------------------------------------------------------------------------
 * Изменение значения ключа
 *
 * При изменении ключа. Находим старый ключ, заменяем значение на новое. Проводим
 * восстановление свойств кучи при необходимости.
 * ------------------------------------------------------------------------------------------------
 * Области использования бинарной кучи
 *
 * Бинарная куча является одной из эффективных реализаций очереди с приоритетом.
 * Очередь с приоритетом (priority queue) - абстрактный тип данных поддерживающий две
 * обязательные операции — добавить элемент и извлечь максимум. Для этого каждому узлу кучи
 * должен соответствовать ключ числового типа (или любого сравнимого между собой типа).
 * Также бинарная куча используется в алгоритме сортировки — пирамидальная сортировка,
 * сортировка кучей.
 * ------------------------------------------------------------------------------------------------
 * <a href="https://youtu.be/kWlF9FcyEUY">Ссылка на видео</a>
 * ------------------------------------------------------------------------------------------------
 */
public class ArrayBasedBinaryHeap {

    public static final int INITIAL_LENGTH = 100;

    private Node[] nodes;
    private int insertIndex;

    public ArrayBasedBinaryHeap() {
        nodes = new Node[INITIAL_LENGTH];
    }

    private class Node {
        int key;
        Object data;

        public Node(int key, Object data) {
            this.key = key;
            this.data = data;
        }

        @Override
        public String toString() {
            return "Node[key=" + key + ", data=" + data + "]";
        }
    }

    public void add(int key, Object data) {
        if (insertIndex == nodes.length) {
            resize();
        }
        nodes[insertIndex] = new Node(key, data);
        insertIndex++;
    }

    private void resize() {

    }

    private void siftUp(int i) {
        while (i > 0) {
            int j = (i - 1) / 2;
            if (nodes[i].key > nodes[j].key) {
                swap(nodes, i, j);
            } else {
                break;
            }
            i = j;
        }
    }

    private void siftDown(int i) {
        while (true) {
            int leftIndex = 2 * i + 1;
            int rightIndex = 2 * i + 2;
            int j = i;
            if (leftIndex <= nodes.length - 1 && nodes[leftIndex].key > nodes[j].key) {
                j = leftIndex;
            }
            if (rightIndex <= nodes.length - 1 && nodes[rightIndex].key > nodes[j].key) {
                j = rightIndex;
            }
            if (i != j) {
                swap(nodes, i, j);
                i = j;
            } else {
                break;
            }
        }
    }

    public static void swap(Object[] a, int i, int j) {
        Object temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }

    //=============================================================================================
    public static void main(String[] args) {

    }
}
