package algorithms.computations.hash_functions;

/**
 * ------------------------------------------------------------------------------------------------
 * Хеш-функция
 * ------------------------------------------------------------------------------------------------
 * Хеш-функция (функция свертки) — функция, генерирующая на основе входных данных
 * произвольной длины, битовую строку фиксированной длины. Процесс генерации называют
 * хешированием. Входные данные иногда называют «ключом», «сообщением». Результирующая
 * битовая строка называется «хешем», «хеш-кодом», «хеш-суммой», «сводкой сообщения».
 * В общем случае множество входящих данных больше множества хешей. Это приводит к тому, что
 * для различных входных данных генерируется один и тот же хеш-код. Такая ситуация называется
 * коллизией.
 * ------------------------------------------------------------------------------------------------
 * Требования выдвигаемые к хеш-функции
 *
 * В большинстве случаев к хеш-функции выдвигается несколько обязательных требований:
 *   1) Детерминированность используемого алгоритма. Следствием из этого является
 *      идентичность хешей при идентичности входных данных.
 *   2) Функция должна работать только с входными данными и не изменять их.
 *
 * «Хорошая» хеш-функция должна обладать следующими желательными (но не обязательными)
 * свойствами:
 *   ● Быстрое вычисление. Хеш-функция должна быстро генерировать код на основе данных.
 *   ● Большая вычислительная сложность обратного вычисления. Должно быть сложно
 *     восстановить вид входящих данных по их хеш-коду (криптографическая стойкость)
 *   ● Малое количество коллизий
 *   ● Равномерное распределение входных данных на множество хеш-кодов
 * ------------------------------------------------------------------------------------------------
 * Часто используемый подход к хешированию
 *
 * Часто используемым подходом к хешированию является представление ключа как
 * целочисленного значения. Если это проблематично, то ищут способ генерация на основе ключа
 * целочисленного значения. В качестве битовой строки результата используется двоичное
 * представление целого числа из определенного диапазона. Таким образом хеш-функция генерирует
 * целое число из определенного диапазона на основе целого числа (созданного на основе ключа) из
 * гораздо более широкого диапазона.
 *                            h(k)
 *   Hello world -> 832992604 -> 100
 *   Ключ -> Целое число на основе ключа -> Хеш
 *
 * Таким образом хеширование сводиться к двум задачам:
 *   Задача 1 — получение на основе ключа целочисленного значения.
 *   Задача 2 — получение с помощью хеш-функции целого числа из меньшего диапазона.
 * ------------------------------------------------------------------------------------------------
 * Пример генерации целого числа на основе ключа
 *
 * Предположим, что ключами являются строки содержащие символы английского языка, цифры и
 * базовые типографические символы. Как создать число на ее основе? Одним из способов является
 * представление строки как числа в системе счисления основание которой равно количеству символов.
 * Возьмем к примеру первые 256 символов ASCII кодировки. В таком случае символ это цифра (код
 * символа), а основание этой системе счисления равно количеству символов 256.
 *
 *   Hello -> 111·256^0 + 108·256^1 + 108·256^2 + 101·256^3 + 72·256^4 = 310939249775
 * ================================================================================================
 * Хеш-функция на основе умножения
 *
 * Хеш-функция на основе умножения строиться следующим образом — умножаем числовое
 * представление ключа на константу 0 < A < 1 и выделяется дробная часть этого произведения.
 * Полученное значение умножается на M. После этого выделяется целая часть результата.
 *
 *   h(K)=⌊M⋅{k⋅A}⌋
 *
 * Для константы A — есть рекомендуемое значение (Дональд Кнут)
 * A = (sqrt(5) - 1) / 2 ≈ 0.6180339887
 *
 * В случае использования этой хеш-функции рекомендуют в качестве M выбирать одно из
 * значений степеней двойки. Эта рекомендация основывается на двоичном представлении машинного
 * слова и приводит к ускорению вычислений.
 * ------------------------------------------------------------------------------------------------
 * Представление ключа в виде полинома
 *
 * Для получения на основе ключа числового представления, можно использовать части ключа как
 * коэффициенты полинома, в качестве значения независимой переменной можно использовать
 * небольшое простое число. Одним из популярных вариантов является выбор значения 31. Это
 * небольшое простое число довольно оптимально для вычисления, т.к. умножение можно свести к
 * битовому сдвигу.
 *
 *   31⋅n = (n << 5) − n
 *   [3, 6, 1] = 3 * 31^2 +  6 * 31^1 + 1 * 31^0 = 3070
 *
 * Для вычисления полиномов такого вида отлично подходит схема Горнера.
 * ------------------------------------------------------------------------------------------------
 * <a href="https://youtu.be/mXu-erfSBDE">Ссылка на видео</a>
 * ------------------------------------------------------------------------------------------------
 */
public class MultiplicationHash {

    public static final double A = 0.6180339887; // рекомендуемое значение (Дональд Кнут)

    public static void main(String[] args) {
        int[] array1 = { 3, 6, 1 };
        System.out.println(hash(array1, 1 << 16));
    }

    public static int arrayToNumber(int[] array) {
        int result = array[0];
        for (int i = 0; i < array.length - 1; i++) {
            result = (result << 5) - result + array[i + 1];
        }
        return result;
    }

    public static int hash(int[] array, int m) {
        int number = Math.abs(arrayToNumber(array));
        return (int) (m * ((number * A) % 1));
    }
}
