package algorithms.computations.hash_functions;

import java.util.Random;

/**
 * ------------------------------------------------------------------------------------------------
 * Хеш-функция
 * ------------------------------------------------------------------------------------------------
 * Хеш-функция (функция свертки) — функция, генерирующая на основе входных данных
 * произвольной длины, битовую строку фиксированной длины. Процесс генерации называют
 * хешированием. Входные данные иногда называют «ключом», «сообщением». Результирующая
 * битовая строка называется «хешем», «хеш-кодом», «хеш-суммой», «сводкой сообщения».
 * В общем случае множество входящих данных больше множества хешей. Это приводит к тому, что
 * для различных входных данных генерируется один и тот же хеш-код. Такая ситуация называется
 * коллизией.
 * ------------------------------------------------------------------------------------------------
 * Требования выдвигаемые к хеш-функции
 *
 * В большинстве случаев к хеш-функции выдвигается несколько обязательных требований:
 *   1) Детерминированность используемого алгоритма. Следствием из этого является
 *      идентичность хешей при идентичности входных данных.
 *   2) Функция должна работать только с входными данными и не изменять их.
 *
 * «Хорошая» хеш-функция должна обладать следующими желательными (но не обязательными)
 * свойствами:
 *   ● Быстрое вычисление. Хеш-функция должна быстро генерировать код на основе данных.
 *   ● Большая вычислительная сложность обратного вычисления. Должно быть сложно
 *     восстановить вид входящих данных по их хеш-коду (криптографическая стойкость)
 *   ● Малое количество коллизий
 *   ● Равномерное распределение входных данных на множество хеш-кодов
 * ------------------------------------------------------------------------------------------------
 * Часто используемый подход к хешированию
 *
 * Часто используемым подходом к хешированию является представление ключа как
 * целочисленного значения. Если это проблематично, то ищут способ генерация на основе ключа
 * целочисленного значения. В качестве битовой строки результата используется двоичное
 * представление целого числа из определенного диапазона. Таким образом хеш-функция генерирует
 * целое число из определенного диапазона на основе целого числа (созданного на основе ключа) из
 * гораздо более широкого диапазона.
 *                            h(k)
 *   Hello world -> 832992604 -> 100
 *   Ключ -> Целое число на основе ключа -> Хеш
 *
 * Таким образом хеширование сводиться к двум задачам:
 *   Задача 1 — получение на основе ключа целочисленного значения.
 *   Задача 2 — получение с помощью хеш-функции целого числа из меньшего диапазона.
 * ------------------------------------------------------------------------------------------------
 * Пример генерации целого числа на основе ключа
 *
 * Предположим, что ключами являются строки содержащие символы английского языка, цифры и
 * базовые типографические символы. Как создать число на ее основе? Одним из способов является
 * представление строки как числа в системе счисления основание которой равно количеству символов.
 * Возьмем к примеру первые 256 символов ASCII кодировки. В таком случае символ это цифра (код
 * символа), а основание этой системе счисления равно количеству символов 256.
 *
 *   Hello -> 111·256^0 + 108·256^1 + 108·256^2 + 101·256^3 + 72·256^4 = 310939249775
 * ================================================================================================
 * Хеш-функция на основе таблицы переходов (хеширование Пирсона)
 *
 * Одной из простых хеш-функций является хеш-функция на основе таблицы переходов
 * (хеширование Пирсона). Эта хеш-функция очень быстро вычисляется и проста в реализации. К
 * недостаткам относится низкая криптографическая стойкость.
 *
 * Принцип построения следующий - строиться таблица (массив) чисел в диапазоне от 0 до
 * размера этой таблицы минус 1 расположенных случайным образом. Очень часто размер этой
 * таблицы составляет 256 элементов (именно такой размер предложен автором). Это означает что
 * результатом будет байтовая строка размером 1 байт (число от 0 до 255). Происходит инициализация
 * начального значения хеша, после чего для каждого элемента ключа хеш пересчитывается. Сначала
 * вычисляется новый индекс.
 *
 * ● Если рассматривать ключ как последовательность байт то используют XOR текущего значения
 *   хеша и очередного байта
 *
 * ● Если рассматривать ключ как последовательность целых чисел, то остаток от деления суммы
 *   текущего значения хеша и очередного числа ключа, на размер таблицы
 *
 * Новым значением хеша становится элемент стоящий на полученном индексе, после чего
 * операция циклически повторяется.
 * ------------------------------------------------------------------------------------------------
 * Хеш-функции на основе таблицы переходов для многобайтового ключа
 *
 * Как создать хеш из нескольких байт используя небольшую таблицу переходов? Можно получить
 * однобайтовый хеш на основе ключа. После чего изменить предсказуемым образом копию ключа и
 * получить еще один однобайтовый хеш. После чего операцию повторить столько раз сколько байт
 * нужно. Объединить байтовые хеши в один многобайтовый.
 * ------------------------------------------------------------------------------------------------
 * <a href="https://youtu.be/mXu-erfSBDE">Ссылка на видео</a>
 * ------------------------------------------------------------------------------------------------
 */
public class TransitionsTableHash {

    public static void main(String[] args) {
        int[] fixedHashTable = {
                98, 6, 85, 150, 36, 23, 112, 164, 135, 207, 169, 5, 26, 64, 165, 219,
                61, 20, 68, 89, 130, 63, 52, 102, 24, 229, 132, 245, 80, 216, 195, 115,
                90, 168, 156, 203, 177, 120, 2, 190, 188, 7, 100, 185, 174, 243, 162, 10,
                237, 18, 253, 225, 8, 208, 172, 244, 255, 126, 101, 79, 145, 235, 228, 121,
                123, 251, 67, 250, 161, 0, 107, 97, 241, 111, 181, 82, 249, 33, 69, 55,
                59, 153, 29, 9, 213, 167, 84, 93, 30, 46, 94, 75, 151, 114, 73, 222,
                197, 96, 210, 45, 16, 227, 248, 202, 51, 152, 252, 125, 81, 206, 215, 186,
                39, 158, 178, 187, 131, 136, 1, 49, 50, 17, 141, 91, 47, 129, 60, 99,
                154, 35, 86, 171, 105, 34, 38, 200, 147, 58, 77, 118, 173, 246, 76, 254,
                133, 232, 196, 144, 198, 124, 53, 4, 108, 74, 223, 234, 134, 230, 157, 139,
                189, 205, 199, 128, 176, 19, 211, 236, 127, 192, 231, 70, 233, 88, 146, 44,
                183, 201, 22, 83, 13, 214, 116, 109, 159, 32, 95, 226, 140, 220, 57, 12,
                221, 31, 209, 182, 143, 92, 149, 184, 148, 62, 113, 65, 37, 27, 106, 166,
                3, 14, 204, 72, 21, 41, 56, 66, 28, 193, 40, 217, 25, 54, 179, 117,
                238, 87, 240, 155, 180, 170, 242, 212, 191, 163, 78, 218, 137, 194, 175, 110,
                43, 119, 224, 71, 122, 142, 42, 160, 104, 48, 247, 103, 15, 11, 138, 239
        };

        int[] hashTable = createIndexArray(256);
        shuffle(hashTable);

        String text = "Hello, Galaxy!";
        System.out.println(text);
        System.out.println();

        System.out.println("Using random hash table:");
        System.out.println("hash8:  " + hash8(text, hashTable));
        System.out.println("hash32: " + hash32(text, hashTable));
        System.out.println();

        System.out.println("Using fixed hash table:");
        System.out.println("hash8:  " + hash8(text, fixedHashTable));
        System.out.println("hash32: " + hash32(text, fixedHashTable));
    }

    public static int hash8(String text, int[] hashTable) {
        // Выбираем начальный hash
//        int hash = 0;                                 // начальный hash равен нулю
//        int hash = text.charAt(0) % 256;              // начальный hash вычисляем из первого символа
//        int hash = hashTable[text.charAt(0) % 256];   // начальный hash вычисляем из таблицы по первому символу
        int hash = text.length() % 256;               // начальный hash вычисляем из длины текста

        for (int i = 0; i < text.length(); i++) {
            hash = hashTable[(hash + text.charAt(i)) % 256];
        }
        return hash;
    }

    public static int hash32(String text, int[] hashTable) {
        int hash32 = 0;
        for (int i = 0; i < 4; i++) {
            // изменяем начальный hash8 для очередного байта (из таблицы по первому символу + i)
            int hash8 = hashTable[(text.charAt(0) + i) % 256];

            for (int j = 0; j < text.length(); j++) {
                hash8 = hashTable[(hash8 + text.charAt(j)) % 256];
            }
            hash32 = hash32 | hash8;
            if (i < 3) {
                hash32 = hash32 << 8;
            }
        }
//        return hash32;
        return hash32 & 0x7FFFFFFF; // откидываем бит знака
    }

    public static int[] createIndexArray(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = i;
        }
        return a;
    }

    public static void shuffle(int[] a) {
        Random random = new Random();
        for (int i = a.length - 1; i >= 1; i--) {
            int j = random.nextInt(i + 1);
            swap(a, i, j);
        }
    }

    public static void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
