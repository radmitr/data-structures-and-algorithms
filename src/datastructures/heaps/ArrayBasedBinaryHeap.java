package datastructures.heaps;

import java.util.Arrays;

/**
 * ------------------------------------------------------------------------------------------------
 * Бинарная куча
 * ------------------------------------------------------------------------------------------------
 * Куча определение
 *
 * Куча (heap) — разновидность дерева (и как следствие разновидность графа). Отличительной
 * особенностью является наличие выделенной вершины (узла) — вершина кучи. Упорядочивание,
 * которое относит кучу к деревьям, следующее - ключ дочернего узла не больше ключа родительского
 * узла. Это приводит к тому, что в вершине кучи всегда расположен элемент с максимальным ключом.
 * ------------------------------------------------------------------------------------------------
 * Поддерживаемые операции
 *
 * Кучи обычно поддерживают следующие операции:
 *   ● Добавление нового узла в кучу
 *   ● Удаление элемента из кучи
 *   ● Найти узел с максимальным значением ключа
 * ------------------------------------------------------------------------------------------------
 * Бинарная куча
 *
 * Бинарная, двоичная куча (пирамида) одна из наиболее часто используемых видов кучи.
 * Отличительными особенностями бинарной кучи являются:
 *   ● У каждого узла не более 2-х дочерних узлов
 *   ● Все уровни дерева (а куча разновидность дерева) заполнены полностью. Исключение
 *     составляет последний уровень, он может быть заполнен не полностью, в этом случае
 *     заполнение обязательно должно идти слева направо
 *   ● Глубина всех листьев отличается максимум на один слой.
 * ------------------------------------------------------------------------------------------------
 * Добавление элемента в кучу
 *
 * Добавляется элемент всегда на первое незаполненное место слоя. При этом может нарушиться
 * свойство бинарной кучи. В таком случае нужно менять значение с родительским узлом до тех пор,
 * пока свойство кучи не будет восстановлено. Такой процесс называется просеиванием вверх.
 * ------------------------------------------------------------------------------------------------
 * Получение максимального элемента с удалением
 *
 * Для удаления максимального элемента, заменяют его последним значением на последнем
 * уровне. Если условие бинарной кучи нарушается, то проводим обмен с максимальным дочерним
 * элементом, до восстановления условий кучи. Такой процесс восстановления свойств кучи называется
 * просеиванием вниз.
 * ------------------------------------------------------------------------------------------------
 * Одновременная вставка и удаление максимального элемента
 *
 * При одновременной вставке и удалении максимального элемента наиболее оптимальным
 * является замена максимального элемента на вставляемый. Если после этого свойства бинарной кучи
 * не соблюдены, то выполняется просеивание вниз.
 * ------------------------------------------------------------------------------------------------
 * Удаление произвольного узла
 *
 * Удаление произвольного узла производится следующим образом — удаляемый узел
 * заменяется на последний узел последнего слоя. Если после замены произошло нарушение свойств
 * бинарной кучи, то применить просеивание вниз.
 * ------------------------------------------------------------------------------------------------
 * Изменение ключа узла
 *
 * При замене значения ключа для узла, нужно заменить значение ключа на новое. Если новый
 * ключ больше родительского, то выполнять просеивание вверх. Если новый ключ меньше дочернего
 * узла, то выполнить просеивание вниз.
 * ================================================================================================
 * Наиболее простая реализация бинарной кучи
 *
 * Наиболее простой и популярной реализацией бинарной кучи является реализация на основе
 * массива (списка). Корневой узел всегда располагается на нулевом индексе элементом. Индексы
 * потомков любого элемента рассчитываются как [2i+1] и [2i+2].
 * ------------------------------------------------------------------------------------------------
 * Добавление элемента
 *
 * При добавлении элемента стоит хранить указатель на последний добавленный элемент. Этот
 * элемент будет последним элементом последнего слоя. Для вычисления индекса родительского узла
 * использовать выражение [i-1]/2.
 * ------------------------------------------------------------------------------------------------
 * Получение максимального элемента с удалением
 *
 * Для удаления максимального элемента, заменяют значение на нулевом индексе значением
 * последнего элемента. После этого выполняют просеивание вниз для этого элемента. Для этого
 * выполняют обмен этого элемента с элементами на индексах [2i+1], [2i+2] (обмен с тем элементом,
 * что больше).
 * ------------------------------------------------------------------------------------------------
 * Поиск элемента по ключу
 *
 * Поиск узла по ключу реализуется с помощью обычного линейного поиска элемента в массиве.
 * ------------------------------------------------------------------------------------------------
 * Восстановление свойств кучи
 *
 * Для восстановления свойств кучи (например, узел с ключом 2 стоит не на своем месте) нужно:
 * 1) Сравнить значение этого узла с родительским. Если значение узла больше родительского, то
 *    применяют просеивание вверх (индекс родителя [(i-1)/2] ).
 * 2) Сравнить значение этого узла с дочерними. Если значение узла меньше, то применяют
 *    просеивание вниз. Обмен с большим из дочерних узлов. Индексы дочерних элементов [2*i + 1],
 *    [2*i + 2]
 * ------------------------------------------------------------------------------------------------
 * Удаление произвольного узла
 *
 * Удаление произвольного узла сводится к замене этого узла на последний. После чего идет
 * восстановление свойств кучи.
 * ------------------------------------------------------------------------------------------------
 * Изменение значения ключа
 *
 * При изменении ключа. Находим старый ключ, заменяем значение на новое. Проводим
 * восстановление свойств кучи при необходимости.
 * ------------------------------------------------------------------------------------------------
 * Области использования бинарной кучи
 *
 * Бинарная куча является одной из эффективных реализаций очереди с приоритетом.
 * Очередь с приоритетом (priority queue) - абстрактный тип данных поддерживающий две
 * обязательные операции — добавить элемент и извлечь максимум. Для этого каждому узлу кучи
 * должен соответствовать ключ числового типа (или любого сравнимого между собой типа).
 * Также бинарная куча используется в алгоритме сортировки — пирамидальная сортировка,
 * сортировка кучей.
 * ------------------------------------------------------------------------------------------------
 * <a href="https://youtu.be/kWlF9FcyEUY">Ссылка на видео</a>
 * ------------------------------------------------------------------------------------------------
 */
public class ArrayBasedBinaryHeap {

    public static final int DEFAULT_LENGTH = 100;

    private Node[] nodes;
    private int insertIndex;

    public ArrayBasedBinaryHeap() {
        nodes = new Node[DEFAULT_LENGTH];
    }

    private class Node {
        int key;
        Object data;

        public Node(int key, Object data) {
            this.key = key;
            this.data = data;
        }

        @Override
        public String toString() {
            return "Node[key=" + key + ", data=" + data + "]";
        }
    }

    public void add(int key, Object data) {
        if (insertIndex == nodes.length) {
            boolean resizeResult = upResize();
            if (!resizeResult) {
                throw new RuntimeException("Cannot add an element");
            }
        }
        nodes[insertIndex] = new Node(key, data);
        siftUp(insertIndex);
        insertIndex++;
    }

    public Object extract() {
        if (insertIndex == 0) {
            return null;
        }
        if (insertIndex == 1) {
            insertIndex--;
            return nodes[insertIndex].data;
        }
        Object result = nodes[0].data;
        insertIndex--;
        nodes[0] = nodes[insertIndex];
        nodes[insertIndex] = null;
        siftDown(0);
        return result;
    }

    public Object insertAndExtract(int key, Object data) {
        if (insertIndex == 0) {
            nodes[0] = new Node(key, data);
            return null;
        }
        Object result = nodes[0].data;
        nodes[0] = new Node(key, data);
        siftDown(0);
        return result;
    }

    public void delete(int key) {
        int i = findIndexByKey(key);
        if (i != -1) {
            Node node = nodes[insertIndex - 1];
            nodes[insertIndex - 1] = null;
            insertIndex--;
            if (insertIndex == 0) {
                return;
            }
            nodes[i] = node;
            heapRecovery(i);
        }
    }

    public void changeKey(int oldKey, int newKey) {
        int i = findIndexByKey(oldKey);
        if (i != -1) {
            nodes[i].key = newKey;
            heapRecovery(i);
        }
    }

    private void siftUp(int i) {
        while (i > 0) {
            int j = (i - 1) / 2;
            if (nodes[i].key > nodes[j].key) {
                swap(nodes, i, j);
            } else {
                break;
            }
            i = j;
        }
    }

    private void siftDown(int i) {
        while (true) {
            int leftIndex = 2 * i + 1;
            int rightIndex = 2 * i + 2;
            int j = i;
            if (leftIndex < insertIndex && nodes[leftIndex].key > nodes[j].key) {
                j = leftIndex;
            }
            if (rightIndex < insertIndex && nodes[rightIndex].key > nodes[j].key) {
                j = rightIndex;
            }
            if (i != j) {
                swap(nodes, i, j);
                i = j;
            } else {
                break;
            }
        }
    }

    public static void swap(Object[] a, int i, int j) {
        Object temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }

    private void heapRecovery(int i) {
        if (i > 0 && nodes[i].key > nodes[(i - 1) / 2].key) {
            siftUp(i);
        } else {
            siftDown(i);
        }
    }

    private int findIndexByKey(int key) {
        for (int i = 0; i < insertIndex; i++) {
            if (nodes[i].key == key) {
                return i;
            }
        }
        return -1;
    }

    private boolean upResize() {
        if (insertIndex >= Integer.MAX_VALUE - 1) {
            return false;
        }
        long newLengthL = (nodes.length * 2L);
        int newLength = (newLengthL < Integer.MAX_VALUE - 1) ? (int) newLengthL : Integer.MAX_VALUE - 1;
        nodes = Arrays.copyOf(nodes, newLength);
        return true;
    }

    @Override
    public String toString() {
        if (insertIndex == 0) {
            return "null";
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < insertIndex; i++) {
            sb.append(nodes[i]).append(System.lineSeparator());
        }
        sb.deleteCharAt(sb.length() - 1);
        return sb.toString();
    }

    //=============================================================================================
    public static void main(String[] args) {
        ArrayBasedBinaryHeap heap = new ArrayBasedBinaryHeap();
        System.out.println(heap);
        System.out.println();

        // 1 - add()
        heap.add(6, "Orange");
        heap.add(7, "Apple");
        heap.add(3, "Plum");
        heap.add(4, "Lemon");
        heap.add(5, "Pear");
        heap.add(9, "Cherry");
        heap.add(12, "Banana");
        System.out.println(heap);
        System.out.println();

        // 2 - extract()
        while (true) {
            Object data = heap.extract();
            if (data == null) {
                break;
            }
            System.out.println(data);
        }
        System.out.println(heap);
        System.out.println();

        // 3 - insertAndExtract()
        heap.add(6, "Orange");
        heap.add(7, "Apple");
        heap.add(3, "Plum");
        heap.add(4, "Lemon");
        heap.add(5, "Pear");
        heap.add(9, "Cherry");
        heap.add(24, "Pineapple");
        System.out.println(heap);
        System.out.println();

        System.out.println(heap.insertAndExtract(8, "Coconut"));
        System.out.println();
        System.out.println(heap);
        System.out.println();

        // 4 - delete()
        heap.delete(4);
        System.out.println(heap);
        System.out.println();

        // 5 - changeKey()
        heap.changeKey(8, 15);
        System.out.println(heap);
        System.out.println();
    }
}
