package algoritms.computations.hash_functions;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * ------------------------------------------------------------------------------------------------
 * Хеш-функция
 * ------------------------------------------------------------------------------------------------
 * Хеш-функция (функция свертки) — функция, генерирующая на основе входных данных
 * произвольной длины, битовую строку фиксированной длины. Процесс генерации называют
 * хешированием. Входные данные иногда называют «ключом», «сообщением». Результирующая
 * битовая строка называется «хешем», «хеш-кодом», «хеш-суммой», «сводкой сообщения».
 * В общем случае множество входящих данных больше множества хешей, это приводит к тому, что
 * для различных входных данных генерируется один и тот же хеш-код. Такая ситуация называется
 * коллизией.
 * ------------------------------------------------------------------------------------------------
 * Требования выдвигаемые к хеш-функции
 *
 * В большинстве случаев к хеш-функции выдвигается несколько обязательных требований:
 *   1) Детерминированность используемого алгоритма. Следствием из этого является
 *      идентичность хешей при идентичности входных данных.
 *   2) Функция должна работать только с входными данными и не изменять их.
 *
 * «Хорошая»  хеш-функция должна обладать следующими желательными (но не обязательными)
 * свойствами:
 *   ● Быстрое вычисление. Хеш-функция должна быстро генерировать код на основе данных.
 *   ● Большая вычислительная сложность обратного вычисления. Должно быть сложно
 *     восстановить вид входящих данных по их хеш-коду (криптографическая стойкость)
 *   ● Малое количество коллизий
 *   ● Равномерное распределение входных данных на множество хеш-кодов
 * ================================================================================================
 * Хеш-функция на основе деления
 *
 * Одной из наиболее простых хеш-функций является хеш-функция на основе деления.
 * Вычисление хеша сводится к вычислению остатка от деления.
 *
 * h(K) = K mod M
 *
 * K - числовое представление ключа
 * M - размер диапазона хешей
 *
 * Для выбора M — существует ряд рекомендаций. Желательно, что бы M было нечетным (Если M
 * четное, то четность хеш-кода совпадает с четностью числового значения ключа).
 * В общем случае не рекомендуется использовать M кратным значению:
 *
 * r^k ± a
 *
 * r — основание системы счисления при генерации числового представления ключа
 * k, a — небольшие числа
 *
 * Рекомендуемым для выбора M  является простое число.
 * ------------------------------------------------------------------------------------------------
 * Один из алгоритмов выбора M
 *
 * Проводят хотя бы приблизительную оценку количества ключей и уровень коллизий между ними
 * (сколько ключей могут давать один и тот же хеш). M — ближайшее простое число к их отношению. В
 * ряде случаев можно использовать табулированное значение (заранее определенное) для различных
 * диапазонов ключей.
 * Пример — предположим у нас есть 3500 ключей, уровень коллизии 5 ключей на один хеш. Тогда
 * в качестве M выбираем значение 691 (близкое к значению 3500/5 = 700).
 * ------------------------------------------------------------------------------------------------
 * <a href="https://youtu.be/mXu-erfSBDE">Ссылка на видео</a>
 * ------------------------------------------------------------------------------------------------
 */
public class DivisionHash {

    private int m;

    private static Map<Integer, Integer> PRIME_NUMBERS = Stream.of(new Integer[][] {
            {10, 7},
            {20, 19},
            {50, 47},
            {100, 97},
            {250, 241},
            {500, 499},
            {1000, 997},
            {2500, 2477},
            {5000, 4999},
            {10000, 9973}
    }).collect(Collectors.toMap(
            data -> data[0],
            data -> data[1],
            (oldValue, newValue) -> newValue,
            TreeMap::new
    ));

    public DivisionHash(int keyRange, int collisionLevel) {
        m = keyRange / collisionLevel;
        for (int key : PRIME_NUMBERS.keySet()) {
            if (key > m) {
                m = PRIME_NUMBERS.get(key);
                break;
            }
        }
    }

    public int getM() {
        return m;
    }

    public int hash(String text) {
        return (int)(textToNumber(text) % m);
    }

    // Только для текста маленькой длины, т.к. long быстро переполняется!!!
    // Основание radix=256 только в учебных целях
    public static long textToNumber(String text) {
        int radix = 256;
        long result = 0;
        int n = text.length();
        for (int i = 0; i < n; i++) {
            result += text.charAt(i) * Math.pow(radix, n - 1 - i);
        }
        return result;
    }

    //===============================================================================
    public static void main(String[] args) {

        DivisionHash hashService = new DivisionHash(40, 2);

        System.out.println("M = " + hashService.getM());

        int hash = hashService.hash("Hello");
        int hash2 = hashService.hash("Hi");
        int hash3 = hashService.hash("Bye");
        System.out.println(hash);
        System.out.println(hash2);
        System.out.println(hash3);
    }
}
