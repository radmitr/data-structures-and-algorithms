package datastructures.heaps;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * ------------------------------------------------------------------------------------------------
 * Бинарная куча
 * ------------------------------------------------------------------------------------------------
 * Куча определение
 *
 * Куча (heap) — разновидность дерева (и как следствие разновидность графа). Отличительной
 * особенностью является наличие выделенной вершины (узла) — вершина кучи. Упорядочивание,
 * которое относит кучу к деревьям, следующее - ключ дочернего узла не больше ключа родительского
 * узла. Это приводит к тому, что в вершине кучи всегда расположен элемент с максимальным ключом.
 * ------------------------------------------------------------------------------------------------
 * Поддерживаемые операции
 *
 * Кучи обычно поддерживают следующие операции:
 *   ● Добавление нового узла в кучу
 *   ● Удаление элемента из кучи
 *   ● Найти узел с максимальным значением ключа
 * ------------------------------------------------------------------------------------------------
 * Бинарная куча
 *
 * Бинарная, двоичная куча (пирамида) одна из наиболее часто используемых видов кучи.
 * Отличительными особенностями бинарной кучи являются:
 *   ● У каждого узла не более 2-х дочерних узлов
 *   ● Все уровни дерева (а куча разновидность дерева) заполнены полностью. Исключение
 *     составляет последний уровень, он может быть заполнен не полностью, в этом случае
 *     заполнение обязательно должно идти слева направо
 *   ● Глубина всех листьев отличается максимум на один слой.
 * ------------------------------------------------------------------------------------------------
 * Добавление элемента в кучу
 *
 * Добавляется элемент всегда на первое незаполненное место слоя. При этом может нарушиться
 * свойство бинарной кучи. В таком случае нужно менять значение с родительским узлом до тех пор,
 * пока свойство кучи не будет восстановлено. Такой процесс называется просеиванием вверх.
 * ------------------------------------------------------------------------------------------------
 * Получение максимального элемента с удалением
 *
 * Для удаления максимального элемента, заменяют его последним значением на последнем
 * уровне. Если условие бинарной кучи нарушается, то проводим обмен с максимальным дочерним
 * элементом, до восстановления условий кучи. Такой процесс восстановления свойств кучи называется
 * просеиванием вниз.
 * ------------------------------------------------------------------------------------------------
 * Одновременная вставка и удаление максимального элемента
 *
 * При одновременной вставке и удалении максимального элемента наиболее оптимальным
 * является замена максимального элемента на вставляемый. Если после этого свойства бинарной кучи
 * не соблюдены, то выполняется просеивание вниз.
 * ------------------------------------------------------------------------------------------------
 * Удаление произвольного узла
 *
 * Удаление произвольного узла производится следующим образом — удаляемый узел
 * заменяется на последний узел последнего слоя. Если после замены произошло нарушение свойств
 * бинарной кучи, то применить просеивание вниз.
 * ------------------------------------------------------------------------------------------------
 * Изменение ключа узла
 *
 * При замене значения ключа для узла, нужно заменить значение ключа на новое. Если новый
 * ключ больше родительского, то выполнять просеивание вверх. Если новый ключ меньше дочернего
 * узла, то выполнить просеивание вниз.
 * ================================================================================================
 * Наиболее простая реализация бинарной кучи
 *
 * Наиболее простой и популярной реализацией бинарной кучи является реализация на основе
 * массива (списка). Корневой узел всегда располагается на нулевом индексе элементом. Индексы
 * потомков любого элемента рассчитываются как [2i+1] и [2i+2].
 * ------------------------------------------------------------------------------------------------
 * Добавление элемента
 *
 * При добавлении элемента стоит хранить указатель на последний добавленный элемент. Этот
 * элемент будет последним элементом последнего слоя. Для вычисления индекса родительского узла
 * использовать выражение [i-1]/2.
 * ------------------------------------------------------------------------------------------------
 * Получение максимального элемента с удалением
 *
 * Для удаления максимального элемента, заменяют значение на нулевом индексе значением
 * последнего элемента. После этого выполняют просеивание вниз для этого элемента. Для этого
 * выполняют обмен этого элемента с элементами на индексах [2i+1], [2i+2] (обмен с тем элементом,
 * что больше).
 * ------------------------------------------------------------------------------------------------
 * Поиск элемента по ключу
 *
 * Поиск узла по ключу реализуется с помощью обычного линейного поиска элемента в массиве.
 * ------------------------------------------------------------------------------------------------
 * Восстановление свойств кучи
 *
 * Для восстановления свойств кучи (например, узел с ключом 2 стоит не на своем месте) нужно:
 * 1) Сравнить значение этого узла с родительским. Если значение узла больше родительского, то
 *    применяют просеивание вверх (индекс родителя [(i-1)/2] ).
 * 2) Сравнить значение этого узла с дочерними. Если значение узла меньше, то применяют
 *    просеивание вниз. Обмен с большим из дочерних узлов. Индексы дочерних элементов [2*i + 1],
 *    [2*i + 2]
 * ------------------------------------------------------------------------------------------------
 * Удаление произвольного узла
 *
 * Удаление произвольного узла сводится к замене этого узла на последний. После чего идет
 * восстановление свойств кучи.
 * ------------------------------------------------------------------------------------------------
 * Изменение значения ключа
 *
 * При изменении ключа. Находим старый ключ, заменяем значение на новое. Проводим
 * восстановление свойств кучи при необходимости.
 * ------------------------------------------------------------------------------------------------
 * Области использования бинарной кучи
 *
 * Бинарная куча является одной из эффективных реализаций очереди с приоритетом.
 * Очередь с приоритетом (priority queue) - абстрактный тип данных поддерживающий две
 * обязательные операции — добавить элемент и извлечь максимум. Для этого каждому узлу кучи
 * должен соответствовать ключ числового типа (или любого сравнимого между собой типа).
 * Также бинарная куча используется в алгоритме сортировки — пирамидальная сортировка,
 * сортировка кучей.
 * ------------------------------------------------------------------------------------------------
 * <a href="https://youtu.be/kWlF9FcyEUY">Ссылка на видео</a>
 * ------------------------------------------------------------------------------------------------
 */
class BinaryHeap {

    public static void main(String[] args) {
        BinaryHeap heap = new BinaryHeap();
        heap.add(6, "Orange");
        heap.add(7, "Apple");
        heap.add(3, "Plum");
        heap.add(4, "Lemon");
        heap.add(5, "Pear");
        heap.add(9, "Cherry");
        heap.add(12, "Banana");
        System.out.println(heap);
        System.out.println();

        while (true) {
            Object data = heap.extract();
            if (data == null) {
                break;
            }
            System.out.println(data);
        }
    }

    private class Node {
        int key;
        Object data;

        public Node(int key, Object data) {
            this.key = key;
            this.data = data;
        }

        @Override
        public String toString() {
            return "Node [key=" + key + ", data=" + data + "]";
        }
    }

    private List<Node> nodes = new ArrayList<>();

    public BinaryHeap() {
        super();
    }

    public void add(int key, Object data) {
        nodes.add(new Node(key, data));
        siftUp(nodes.size() - 1);
    }

    public Object extract() {
        if (nodes.size() == 0) {
            return null;
        }
        if (nodes.size() == 1) {
            return nodes.remove(nodes.size() - 1).data;
        }
        Object result = nodes.get(0).data;
        nodes.set(0, nodes.remove(nodes.size() - 1));
        siftDown(0);
        return result;
    }

    public Object insertAndExtract(int key, Object data) {
        if (nodes.size() == 0) {
            nodes.add(new Node(key, data));
            return null;
        }
        Object result = null;
        result = nodes.get(0);
        nodes.set(0, new Node(key, data));
        siftDown(0);
        return result;
    }

    public void delete(int key) {
        int i = findIndexByKey(key);
        if (i != -1) {
            Node node = nodes.remove(nodes.size() - 1);
            if (nodes.size() == 0) {
                return;
            }
            nodes.set(i, node);
            heapRecovery(i);
        }
    }

    public void changeKey(int oldKey, int newKey) {
        int i = findIndexByKey(oldKey);
        if (i != -1) {
            nodes.get(i).key = newKey;
            heapRecovery(i);
        }
    }

    private void siftUp(int i) {
        while (i > 0) {
            int j = (i - 1) / 2;
            if (nodes.get(i).key > nodes.get(j).key) {
                Collections.swap(nodes, i, j);
            } else {
                break;
            }
            i = j;
        }
    }

    private void siftDown(int i) {
        while (true) {
            int leftIndex = 2 * i + 1;
            int rightIndex = 2 * i + 2;
            int j = i;
            if (leftIndex <= nodes.size() - 1 && nodes.get(leftIndex).key > nodes.get(j).key) {
                j = leftIndex;
            }
            if (rightIndex <= nodes.size() - 1 && nodes.get(rightIndex).key > nodes.get(j).key) {
                j = rightIndex;
            }
            if (i != j) {
                Collections.swap(nodes, i, j);
                i = j;
            } else {
                break;
            }
        }
    }

    private void heapRecovery(int i) {
        if (i > 0 && nodes.get(i).key > nodes.get((i - 1) / 2).key) {
            siftUp(i);
            return;
        }
        siftDown(i);
    }

    private int findIndexByKey(int key) {
        for (int i = 0; i < nodes.size(); i++) {
            if (nodes.get(i).key == key) {
                return i;
            }
        }
        return -1;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (Node node : nodes) {
            sb.append(node).append(System.lineSeparator());
        }
        return sb.toString();
    }
}
