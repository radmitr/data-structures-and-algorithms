package algorithms.computations.fibonacci;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * ------------------------------------------------------------------------------------------------
 * Ряд Фибоначчи
 * ------------------------------------------------------------------------------------------------
 * Ряд (последовательность) Фибоначчи — последовательность целых чисел.
 * Задается линейным рекуррентным соотношением.
 *
 * F0 = 0, F1 = 1, Fn = Fn−1 + Fn−2
 * n ⩾ 2, n ∈ ℤ
 *
 * Иногда последовательность Фибоначчи продолжают и в область отрицательных
 * чисел для этого используется «обратная формула».
 * Fn = Fn+1 + Fn+2
 * ------------------------------------------------------------------------------------------------
 * Сведения о ряде Фибоначчи
 *
 * F1 + F2 + F3 + F4 + ... + Fn = Fn+2 − 1
 * F1 + F3 + F5 + F7 + ... + F2n−1 = F2n
 * F2 + F4 + F6 + F8 + ... + F2n = F2n+1 − 1
 *
 * Формула Бине выражает в явном виде зависимость:
 *
 * Fn(n) = ( ((1 + √5)/2)^n - ((1 - √5)/2)^n )/√5 = φ^n − (−φ)^−n
 * где φ = (1 + √5)/2 - золотое сечение
 * ------------------------------------------------------------------------------------------------
 * Применение и способ вычисления ряда Фибоначчи
 *
 * Ряды Фибоначчи используются как в математических исследованиях, в моделировании
 * биологических процессов и в некоторых алгоритмах (например в алгоритме поиска Фибоначчи).
 * Поэтому рассмотрения способов генерации этой последовательности выглядит довольно
 * интересным. Наиболее часто используются следующие подходы:
 *   1) Циклический
 *   2) Рекурсивный
 *   3) Рекурсивный плюс мемоизация
 * ------------------------------------------------------------------------------------------------
 * Генерация с помощью рекурсии
 *
 * Такое решение хоть и простое, но обладает существенными недостатками. При таком решение
 * получается параллельная (множественная) рекурсия. Поэтому довольно быстро количество
 * рекурсивных вызовов превышает предельно допустимое и вычисляется очень долго. Например
 * уже вычисление 50 члена ряда Фибоначчи становится очень долгим.
 * ------------------------------------------------------------------------------------------------
 * Генерация с помощью рекурсии с мемоизацией
 *
 * Применение мемоизации снимает проблему множественных вызовов.
 * ------------------------------------------------------------------------------------------------
 * Теорема Цекендорфа
 *
 * Теорема Цекендорфа гласит, что всякое натуральное число можно единственным образом
 * представить в виде суммы одного или нескольких различных чисел Фибоначчи так, чтобы в этом
 * представлении не оказалось двух соседних чисел из последовательности Фибоначчи.
 *
 * Для любого натурального числа N существуют натуральные числа:
 *   ci ⩾ 2, ci+1 > ci + 1
 *       k
 *   N = ∑ F(ci)
 *      i=0
 *   Где ci — член ряда Фибоначчи
 *
 * Например, представление Цекендорфа для 100 = 89 + 8 + 3.
 *
 * В то же время разложения вида:
 *   100 = 89 + 8 + 2 + 1
 *   100 = 55 + 34 + 8 + 3
 * не являются представлением Цекендорфа поскольку 1 и 2 или 34 и 55 являются последовательными
 * числами Фибоначчи.
 * ------------------------------------------------------------------------------------------------
 * Цель исследования
 *
 * Целью исследования является реализация алгоритма для нахождения представления
 * Цекендорфа для произвольного натурального числа. Также можно исследовать количество
 * членов в подобном разложении.
 *
 * В основу реализации этого алгоритма положим вычисление n члена ряда Фибоначчи
 * рекурсивным методом с использованием мемоизации. Так, как при решении нам явно
 * потребуются все промежуточные результаты, то будем использовать подход с хранением всех
 * промежуточных вычислений.
 * ------------------------------------------------------------------------------------------------
 * Описание алгоритма
 *
 * 1) Находим такое целое число k, что F(k)≤N, где N - это число, представление Цекендрофа которого
 *    мы ищем.
 *
 * 2) Если F(k)≤N, заносим F(k) в результирующее разбиение и указываем новое значение N как N-F(k).
 *    Уменьшаем значение k на единицу. Переходим к пункту 3.
 *
 * 3) Если N=0 заканчиваем алгоритм в противном случае возвращаемся к пункту 2.
 * ------------------------------------------------------------------------------------------------
 * <a href="https://youtu.be/Q3oElm5kGgo">Ссылка на видео</a>
 * ------------------------------------------------------------------------------------------------
 */
public class FibonacciZeckendorf {

    static Map<Integer, BigInteger> mem = new HashMap<>();

    public static void main(String[] args) {
        for (int i = 0; i <= 12; i++) {
            System.out.println(i + " -> " + fibonacciSequence(i));
        }
        System.out.println("-------------------------------");

        // 1
        int number = 100;
        System.out.println(number +" => " + representationOfZeckendorf(BigInteger.valueOf(number)));

        // 2
        int number2 = 143;
        System.out.println(number2 +" => " + representationOfZeckendorf(BigInteger.valueOf(number2)));
    }

    public static BigInteger fibonacciSequence(int n) {
        BigInteger result = mem.get(n);
        if (result != null) {
            return result;
        } else if (n == 0) {
            mem.put(0, BigInteger.ZERO);
        } else if (n == 1) {
            mem.put(1, BigInteger.ONE);
        } else {
            mem.put(n, fibonacciSequence(n - 1).add(fibonacciSequence(n - 2)));
        }
        return mem.get(n);
    }

    public static List<BigInteger> representationOfZeckendorf(BigInteger number) {
        List<BigInteger> roz = new ArrayList<>();
        int k = 0;
        while (fibonacciSequence(k).compareTo(number) <= 0) {
            k = k + 1;
        }
        while (number.compareTo(BigInteger.ZERO) > 0) {
            if (fibonacciSequence(k).compareTo(number) <= 0) {
                BigInteger n = fibonacciSequence(k);
                roz.add(n);
                number = number.subtract(n);
            }
            k = k - 1;
        }
        return roz;
    }
}
