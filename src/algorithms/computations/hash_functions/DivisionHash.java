package algorithms.computations.hash_functions;

import java.math.BigInteger;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * ------------------------------------------------------------------------------------------------
 * Хеш-функция
 * ------------------------------------------------------------------------------------------------
 * Хеш-функция (функция свертки) — функция, генерирующая на основе входных данных
 * произвольной длины, битовую строку фиксированной длины. Процесс генерации называют
 * хешированием. Входные данные иногда называют «ключом», «сообщением». Результирующая
 * битовая строка называется «хешем», «хеш-кодом», «хеш-суммой», «сводкой сообщения».
 * В общем случае множество входящих данных больше множества хешей. Это приводит к тому, что
 * для различных входных данных генерируется один и тот же хеш-код. Такая ситуация называется
 * коллизией.
 * ------------------------------------------------------------------------------------------------
 * Требования выдвигаемые к хеш-функции
 *
 * В большинстве случаев к хеш-функции выдвигается несколько обязательных требований:
 *   1) Детерминированность используемого алгоритма. Следствием из этого является
 *      идентичность хешей при идентичности входных данных.
 *   2) Функция должна работать только с входными данными и не изменять их.
 *
 * «Хорошая» хеш-функция должна обладать следующими желательными (но не обязательными)
 * свойствами:
 *   ● Быстрое вычисление. Хеш-функция должна быстро генерировать код на основе данных.
 *   ● Большая вычислительная сложность обратного вычисления. Должно быть сложно
 *     восстановить вид входящих данных по их хеш-коду (криптографическая стойкость)
 *   ● Малое количество коллизий
 *   ● Равномерное распределение входных данных на множество хеш-кодов
 * ------------------------------------------------------------------------------------------------
 * Часто используемый подход к хешированию
 *
 * Часто используемым подходом к хешированию является представление ключа как
 * целочисленного значения. Если это проблематично, то ищут способ генерация на основе ключа
 * целочисленного значения. В качестве битовой строки результата используется двоичное
 * представление целого числа из определенного диапазона. Таким образом хеш-функция генерирует
 * целое число из определенного диапазона на основе целого числа (созданного на основе ключа) из
 * гораздо более широкого диапазона.
 *                            h(k)
 *   Hello world -> 832992604 -> 100
 *   Ключ -> Целое число на основе ключа -> Хеш
 *
 * Таким образом хеширование сводиться к двум задачам:
 *   Задача 1 — получение на основе ключа целочисленного значения.
 *   Задача 2 — получение с помощью хеш-функции целого числа из меньшего диапазона.
 * ------------------------------------------------------------------------------------------------
 * Пример генерации целого числа на основе ключа
 *
 * Предположим, что ключами являются строки, содержащие символы английского языка, цифры и
 * базовые типографические символы. Как создать число на ее основе? Одним из способов является
 * представление строки как числа в системе счисления основание которой равно количеству символов.
 * Возьмем, к примеру, первые 256 символов ASCII кодировки. В таком случае символ — это цифра (код
 * символа), а основание этой системе счисления равно количеству символов 256.
 *
 *   Hello -> 111·256^0 + 108·256^1 + 108·256^2 + 101·256^3 + 72·256^4 = 310939249775
 * ================================================================================================
 * Хеш-функция на основе деления
 *
 * Одной из наиболее простых хеш-функций является хеш-функция на основе деления.
 * Вычисление хеша сводится к вычислению остатка от деления.
 *
 *   h(K) = K mod M
 *
 * K - числовое представление ключа
 * M - размер диапазона хешей
 *
 * Для выбора M — существует ряд рекомендаций. Желательно, что бы M было нечетным (Если M
 * четное, то четность хеш-кода совпадает с четностью числового значения ключа).
 * В общем случае не рекомендуется использовать M кратным значению:
 *
 *   r^k ± a
 *
 * r — основание системы счисления при генерации числового представления ключа
 * k, a — небольшие числа
 *
 * Рекомендуемым для выбора M  является простое число.
 * ------------------------------------------------------------------------------------------------
 * Один из алгоритмов выбора M
 *
 * Проводят хотя бы приблизительную оценку количества ключей и уровень коллизий между ними
 * (сколько ключей могут давать один и тот же хеш). M — ближайшее простое число к их отношению. В
 * ряде случаев можно использовать табулированное значение (заранее определенное) для различных
 * диапазонов ключей.
 *
 * Пример — предположим у нас есть 3500 ключей, уровень коллизии: 5 ключей на один хеш. Тогда
 * в качестве M выбираем значение 691 (близкое к значению 3500/5 = 700).
 * ------------------------------------------------------------------------------------------------
 * <a href="https://youtu.be/mXu-erfSBDE">Ссылка на видео</a>
 * ------------------------------------------------------------------------------------------------
 */
public class DivisionHash {

    private int m;

    private static Map<Integer, Integer> PRIME_NUMBERS = Stream.of(new Integer[][] {
            {10, 7},
            {20, 19},
            {50, 47},
            {100, 97},
            {250, 241},
            {500, 499},
            {1000, 997},
            {2500, 2477},
            {5000, 4999},
            {10000, 9973}
    }).collect(Collectors.toMap(
            data -> data[0],
            data -> data[1],
            (oldValue, newValue) -> newValue,
            TreeMap::new
    ));

    public DivisionHash(int keyRange, int collisionLevel) {
        m = keyRange / collisionLevel;
        for (int key : PRIME_NUMBERS.keySet()) {
            if (key > m) {
                m = PRIME_NUMBERS.get(key);
                break;
            }
        }
    }

    public int getM() {
        return m;
    }

//    public int hash(String text) {
//        return (int)(textToNumber(text) % m);
//    }

    // Только для текста маленькой длины, т.к. long быстро переполняется!!!
//    public static long textToNumber(String text) {
//        int radix = 256;
//        long result = 0;
//        int n = text.length();
//        for (int i = 0; i < n; i++) {
//            result += text.charAt(i) * Math.pow(radix, n - 1 - i);
//        }
//        return result;
//    }

    public int hash(String text) {
        return textToNumber(text).remainder(BigInteger.valueOf(m)).intValue();
    }

    // В учебных целях используем BigInteger. Не эффективный способ.
    public static BigInteger textToNumber(String text) {
        BigInteger radix = new BigInteger("256");
        BigInteger result = BigInteger.ZERO;
        int n = text.length();
        for (int i = 0; i < n; i++) {
            result = result.add(BigInteger.valueOf(text.charAt(i)).multiply(radix.pow(n - 1 - i)));
        }
        return result;
    }
    //=============================================================================================
    public static void main(String[] args) {
//        DivisionHash hashService = new DivisionHash(40, 2);
        DivisionHash hashService = new DivisionHash(2500, 4);

        System.out.println("m = " + hashService.getM());

        int hash1 = hashService.hash("Hello");
        int hash2 = hashService.hash("Hello world");
        int hash3 = hashService.hash("Bye");
        int hash4 = hashService.hash("+++ Hello world 1234567890 Bye +++");
        System.out.println(hash1);
        System.out.println(hash2);
        System.out.println(hash3);
        System.out.println(hash4);
    }
}
