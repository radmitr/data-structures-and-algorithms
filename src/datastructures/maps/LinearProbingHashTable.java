package datastructures.maps;

import java.util.Arrays;
import java.util.Random;

/**
 * ------------------------------------------------------------------------------------------------
 * Ассоциативный массив на основе хеш-таблиц
 * ------------------------------------------------------------------------------------------------
 * Ассоциативный массив
 *
 * Ассоциативный массив — абстрактный тип данных, позволяющий хранить пары вида «(ключ, значение)».
 * Предполагается, что ассоциативный массив не может хранить две пары с одинаковыми ключами.
 *
 * Поддерживаемые операции:
 *   ● Добавление пары
 *   ● Удаление пары
 *   ● Поиск пары и поиск значения по ключу
 *   ● Получение размера ассоциативного массива
 * ------------------------------------------------------------------------------------------------
 * Хеш-таблица
 *
 * В качестве хеш-таблицы выступает массив (или список), в котором элементы хранятся парами
 * ключ-значение. Индекс для хранения пары определяется хеш-кодом ключа. При этом хеш-функция
 * выбирается такая, что бы генерировать хеш-код в диапазоне индексов этого массива.
 * ------------------------------------------------------------------------------------------------
 * Разрешение коллизий
 *
 * Диапазон всех ключей гораздо больше диапазона индексов в хеш таблице. Таким образом
 * возможны коллизии. Это означает, что для разных ключей генерируется один и тот же хеш-код и как
 * следствие они должны быть размещены по одному и тому же индексу.
 *
 * Способы разрешения коллизий:
 *   1) Метод списков
 *   2) Открытая адресация
 * ================================================================================================
 * Метод открытой адресации
 *
 * В хеш-таблице хранятся сами пары ключ-значение. Алгоритм вставки элемента проверяет
 * ячейку массива в некотором порядке до тех пор, пока не будет найдена первая свободная ячейка,
 * в которую и будет записан новый элемент.
 * ------------------------------------------------------------------------------------------------
 * Линейное пробирование
 *
 * Последовательность, в которой просматриваются ячейки хеш-таблицы, называется
 * последовательностью проб. Одна из самых простых (и в то же время эффективная) — это линейное
 * пробирование. Его суть сводиться к просмотру индексов (при коллизии) по порядку с шагом в 1
 * до нахождения первого свободного места.
 *
 * Последовательность проб
 *
 *   h(key ,i) = (h(key ) + i) mod N
 *
 *   N - размер хеш-таблицы
 *   i - номер попытки
 * ------------------------------------------------------------------------------------------------
 * Используемая хеш-функция
 *
 * Хеш-таблица с открытой адресацией (линейное пробирование) чувствительна к виду
 * используемой хеш-функции. И хотя работать она будет с любой, для оптимальной
 * производительности стоит использовать семейство функций k-независимого хеширования.
 * Одним из таких является псевдослучайное полиномиальное хеширование.
 *
 * Идея хеширование следующая. Выбирается простое число p, также используют значение
 * p=2n. Выбираются как минимум k=5 случайных чисел (которые фиксируются) из диапазона [0..p-1].
 * Эти числа выступают коэффициентами полинома. В таком случае хеш-код вычисляется
 * следующим образом.
 *
 *             k−1
 *   h(key) = (∑Ai⋅n⋅key^i)⋅mod p
 *             i=0
 *
 *   n(key ) - числовое представление ключа
 *   Ai - случайное число выступающее как коэффициент полинома
 *
 * ------------------------------------------------------------------------------------------------
 * Пример псевдослучайного полиномиального хеширования
 *
 * Выбираем значение p = 2^4 = 16
 *
 * Генерируем 5 случайных чисел в диапазоне от 0..15:
 * -------------------------------
 * | i  | 0  | 1  | 2  | 3  | 4  |
 * |-----------------------------|
 * | Ai | 7  | 2  | 13 | 5  | 11 |
 * -------------------------------
 *
 * Полученная хеш-функция равна:
 *   h(key) = (7 + 2⋅n(key) + 13⋅n(key)^2 + 5⋅n(key)^3 + 11⋅n(key)^4)⋅mod 16
 * ------------------------------------------------------------------------------------------------
 * Добавление пары (ключа нет в хеш-таблице)
 *
 * При добавлении пары, вычисляем индекс на который попадет элемент, если на этом индексе
 * нет элемента, то добавляем пару ключ значение и заканчиваем. Если же этот индекс уже занят, то
 * переходим к следующему элементу и так далее.
 *
 * 1) Вычисляем хеш-код ключа.
 * 2) Переходим к индексу равному полученному хеш-коду. Этот индекс уже занят. Переходим к
 *    следующему индексу.
 * 3) Этот индекс также занят. Переходи к следующему.
 * 4) Этот индекс свободен. Записываем пару ключ-значение на полученный индекс.
 * ------------------------------------------------------------------------------------------------
 * Добавление пары (ключ есть в хеш-таблице)
 *
 * При добавлении пары вычисляем индекс, на который попадет элемент, если на этом индексе
 * есть элемент с равным ключом, заменяем значение на добавляемое и заканчиваем.
 *
 * 1) Вычисляем хеш-код ключа.
 * 2) Переходим к индексу равному полученному хеш-коду. Этот индекс уже занят. Переходим к
 *    следующему индексу.
 * 3) Этот индекс также занят. Хеш-код пары равен добавляемому.
 * 4) Заменяем значение пары, на добавляемое значение.
 * ------------------------------------------------------------------------------------------------
 * Поиск пары по ключу
 *
 * При поиске пары по ключу, вычисляем хеш-код ключа. Переходим по индексу равному
 * полученному хеш-коду. Если на индексе нет пары, то поиск неудачен. Если ключ пары на индексе
 * равен искомому, возвращаем значение, если нет переходим к следующему индексу.
 *
 * 1) Вычисляем хеш-код ключа.
 * 2) Переходим к индексу равному полученному хеш-коду. Там есть пара. Ее ключ не равен искомому.
 *    Переходим к следующему индексу.
 * 3) На этом индексе есть пара. Ее ключ равен искомому.
 * 4) Возвращаем значение найденной пары.
 * ------------------------------------------------------------------------------------------------
 * Удаление пары по ключу
 *
 * Вычисляем хеш-код ключа. Переходим по индексу равному полученному хеш-коду. Если на
 * индексе нет пары, заканчиваем такой пары нет. Методом проб находим пару ключ, которой равен
 * удаляемому. Удаляем пару. После чего выполняем смещение все последующих пар (до следующей
 * пустой позиции) на одну позицию влево.
 *
 * 1) Вычисляем хеш-код ключа.
 * 2) Переходим к индексу равному полученному хеш-коду. Тут есть пара. Ключ не равен удаляемому.
 *    Переходим к следующему элементу. Ключ пары равен удаляемому.
 * 3) Удаляем найденный элемент.
 * 4) Производим сдвиг пар (до следующего отсутствующего элемента) на одну позицию влево.
 * ------------------------------------------------------------------------------------------------
 * Увеличение размера хеш-таблицы
 *
 * В случае использования линейного пробирования увеличение размера стоит выполнять при
 * коэффициенте заполнения 0.5. Увеличивают размер массива в два раза, и просто последовательно
 * добавляют пары (используя тот же алгоритм добавления) из старого массива в новый. После
 * окончания работы освобождают память (при необходимости) занимаемую старым массивом. В
 * качестве хеш-таблицы используем новый.
 * ------------------------------------------------------------------------------------------------
 * Получение размера ассоциативного массива
 *
 * Возможны два варианта получения количества элементов:
 *   1) Объявление дополнительной переменной с начальным значением равной 0. При добавлении пары
 *      ключ значение, увеличиваем значение на единицу. При удалении уменьшаем. В таком случае в
 *      любой момент времени значение этой переменной равно количеству элементов.
 *   2) Пройти по всем элементам хеш-таблицы. Просуммировать количество существующих элементов.
 * ------------------------------------------------------------------------------------------------
 * <a href="https://youtu.be/KPRQuf39ZzQ">Ссылка на видео</a>
 * ------------------------------------------------------------------------------------------------
 */
class LinearProbingHashTable {

    public static final int INITIAL_CAPACITY = 16;

    private Pair[] pairArray;
    private int capacity = INITIAL_CAPACITY;
//    private int[] polyCoeff = new int[5];
    public int[] polyCoeff = new int[5]; // для теста public
    private int size = 0;

    public LinearProbingHashTable() {
        pairArray = new Pair[capacity];
        calculatePolyCoeff();
    }

    private class Pair {
        public String key;
        public Object value;

        public Pair(String key, Object value) {
            this.key = key;
            this.value = value;
        }
    }

    private void calculatePolyCoeff() {
//        Random random = new Random();
        Random random = new Random(0); // для теста seed = 0
        for (int i = 0; i < polyCoeff.length; i++) {
            polyCoeff[i] = random.nextInt(capacity);
        }
    }

    private int calculateNewHash(int oldHash) {
        int newHash = polyCoeff[0];
        for (int i = 0; i < polyCoeff.length - 1; i++) {
            newHash = newHash * oldHash + polyCoeff[i + 1];
        }
        return Math.abs(newHash % capacity);
    }

    public void addPair(String key, Object value) {
        int index = calculateNewHash(key.hashCode());
        while (true) {
            if (pairArray[index] == null) {
                pairArray[index] = new Pair(key, value);
                System.out.println(key + ":" + value + ", (index=" + index + ")"); // трассировка
                size++;
                break;
            } else if (pairArray[index].key.equals(key)) {
                pairArray[index].value = value;
                System.out.println(key + ":" + value + ", (index=" + index + ")"); // трассировка
                break;
            } else {
                System.out.println(key + ":" + value + ", (index=" + index + ")"); // трассировка
                index = (index + 1) % capacity;
            }
        }
        if (size > capacity / 2) {
            upResize();
        }
    }

    private void upResize() {
        int newCapacity = capacity * 2;
        if (newCapacity < 0) {
            throw new RuntimeException("Can not increase the capacity");
        }
        Pair[] oldPairArray = pairArray;
        pairArray = new Pair[newCapacity];
        capacity = newCapacity;
        calculatePolyCoeff();
        for (Pair pair : oldPairArray) {
            if (pair != null) {
                addPair(pair.key, pair.value);
            }
        }
    }

    public Object get(String key) {
        int index = calculateNewHash(key.hashCode());
        while (true) {
            if (pairArray[index] == null) {
                return null;
            } else if (pairArray[index].key.equals(key)) {
                return pairArray[index].value;
            } else {
                index = (index + 1) % capacity;
            }
        }
    }

    public boolean remove(String key) {
        int index = calculateNewHash(key.hashCode());
        while (true) {
            if (pairArray[index] == null) {
                return false;
            } else if (pairArray[index].key.equals(key)) {
                pairArray[index] = null;
                while (true) {
                    pairArray[index] = pairArray[(index + 1) % capacity];
                    if (pairArray[index] == null) {
                        break;
                    }
                    index = (index + 1) % capacity;
                }
                size--;
                return true;
            } else {
                index = (index + 1) % capacity;
            }
        }
    }

    public int getSize() {
        return size;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("{");
        for (Pair pair : pairArray) {
            if (pair != null) {
                sb.append(pair.key).append(":").append(pair.value).append(", ");
            } else {
                sb.append("null, "); // для теста
            }
        }
        sb.delete(sb.length() - 2, sb.length());
        return sb.append("}").toString();
    }

    //=============================================================================================
    public static void main(String[] args) {
        LinearProbingHashTable hashTable = new LinearProbingHashTable();
        System.out.println(hashTable);

        System.out.println(Arrays.toString(hashTable.polyCoeff));

        hashTable.addPair("one", 1);
        hashTable.addPair("two", 2);
        hashTable.addPair("three", 3);
        hashTable.addPair("four", 4);
        hashTable.addPair("five", 5);
        hashTable.addPair("nine", 9);
        System.out.println(hashTable);

        hashTable.remove("one");
        System.out.println(hashTable);

        System.out.println(hashTable.get("two"));

//        System.out.println(hashTable.get("nine"));
//        System.out.println(hashTable);
//
//        hashTable.remove("four");
//        System.out.println(hashTable);
//
//        hashTable.addPair("four", 4);
//        hashTable.addPair("six", 6);
//        hashTable.addPair("seven", 7);
//        System.out.println(hashTable);
    }
}
