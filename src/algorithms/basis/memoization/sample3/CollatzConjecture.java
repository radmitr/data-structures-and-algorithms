package algorithms.basis.memoization.sample3;

import java.math.BigInteger;
import java.util.HashMap;
import java.util.Map;

/**
 * ------------------------------------------------------------------------------------------------
 * Мемоизация
 * ------------------------------------------------------------------------------------------------
 * Мемоизация — сохранение результатов выполнения функций для предотвращения
 * повторных вычислений. Применяется для увеличения скорости выполнения программ.
 * Основной механизм реализации - перед вызовом функции проверяется, вызывалась ли
 * функция ранее:
 *   ● если не вызывалась, то функция вызывается, и результат её выполнения
 *     сохраняется;
 *   ● если вызывалась, то используется сохранённый результат.
 *
 * Мемоизацию можно отнести к разновидности кеширования данных. При работе с
 * рекурсивными функциями может повышать производительность.
 * ------------------------------------------------------------------------------------------------
 * Общие идее при реализации мемоизации
 *
 * Нужно создать элемент (в дальнейшем хранилище) который способен хранить пары значений с
 * последующим быстрым извлечением. Для этого идеально подойдут ассоциативные массивы
 * (словарь, карта) в качестве ключа использовать значение параметра функции, в качестве значения
 * результат ее работы. В таком случае при вызове функции сначала проверяем нет ли таких
 * параметров в хранилище (проверяем наличие такого ключа) и если они там есть, то возвращаем
 * значение не выполняя при этом тело функции, если же таких параметров в хранилище нет, то
 * выполняем тело функции после чего записываем в хранилище пару ключ которой равен
 * параметрам, а значение вычисленному результату. После чего возвращаем вычисленное значение.
 * ------------------------------------------------------------------------------------------------
 * Замечания по использованию мемоизации
 *
 * Общие рекомендации при применении мемоизации:
 *   ● Для того, чтобы функцию можно было подвергнуть мемоизации, она должна быть чистой:
 *     ● детерминированной (т.е. при одном и том же наборе параметров функции должна
 *       возвращать одинаковое значение)
 *     ● без побочных эффектов (т.е. не должна влиять на состояние системы).
 *   ● Мемоизация — это компромисс между производительностью и потреблением памяти.
 * Мемоизация хороша для функций, имеющих сравнительно небольшой диапазон входных
 * значений, что позволяет достаточно часто, при повторных вызовах функций, задействовать
 * значения, найденные ранее, не тратя на хранение данных слишком много памяти.
 *   ● Функции с мемоизацией хорошо показывают себя там, где выполняются сложные,
 *     ресурсоёмкие вычисления. Здесь данная техника может значительно повысить
 *     производительность решения.
 * ================================================================================================
 * Интересная задача где можно применить мемоизацию
 *
 * Для демонстрации интересной задачи с мемоизацией исследуем гипотезу Коллатца.
 * Гипотеза Коллатца (3n+1 дилемма, сиракузская проблема) — одна из нерешённых
 * проблем математики. На основании любого натурального числа генерируется
 * следующее натуральное число по следующему правилу:
 *   ● Число четное, тогда результат получается делением на 2
 *   ● Число не четное, тогда результат 3n+1, где n — число
 * Гипотеза заключается в том, что для любого натурального числа n эта
 * последовательность вернет число 1. И последовательность перейдет в режим цикла.
 * ------------------------------------------------------------------------------------------------
 * Пример сиракузской последовательности
 *
 * Например, для числа 3 получаем:
 *     3 — нечётное, 3×3 + 1 = 10
 *     10 — чётное, 10:2 = 5
 *     5 — нечётное, 5×3 + 1 = 16
 *     16 — чётное, 16:2 = 8
 *     8 — чётное, 8:2 = 4
 *     4 — чётное, 4:2 = 2
 *     2 — чётное, 2:2 = 1
 *     1 — нечётное, 1×3 + 1 = 4
 * Далее, начиная с 1, начинают циклически повторяться числа 1, 4, 2.
 * ------------------------------------------------------------------------------------------------
 * Суть исследования
 *
 * Для ряда натуральных чисел вычислим длину последовательности до попадания ее
 * в цикл. Например для числа 3 длинна последовательности равна 7 (по сути сколько
 * членов было создано до достижения 1). Задание функции рекурсивно по своей природе,
 * но применение мемоизации поможет ускорить процесс.
 * ------------------------------------------------------------------------------------------------
 * <a href="https://youtu.be/VwmJ-Lj1Qsk">Ссылка на видео</a>
 * ------------------------------------------------------------------------------------------------
 */
public class CollatzConjecture {

    public static Map<BigInteger, BigInteger> mem = new HashMap<>();

    public static void main(String[] args) {
        BigInteger number0 = BigInteger.valueOf(3);
        System.out.printf("{%d=%d}\n",number0, getSyracuseSequenceLength(number0));
        System.out.println(mem);
        System.out.println();

        BigInteger number1 = BigInteger.valueOf(19);
        System.out.printf("{%d=%d}\n",number1, getSyracuseSequenceLength(number1));
        System.out.println(mem);
        System.out.println();

        BigInteger number2 = BigInteger.valueOf(40);
        System.out.printf("{%d=%d}\n",number2, getSyracuseSequenceLength(number2));
        System.out.println(mem);
        System.out.println();

        BigInteger number3 = BigInteger.valueOf(27);
        System.out.printf("{%d=%d}\n",number3, getSyracuseSequenceLength(number3));
        System.out.println(mem);
        System.out.println();
        getSyracuseSequenceLength(number3);

//        BigInteger number4 = new BigInteger("3555566607345645457467443456887894333647475686855463453789700011");
//        System.out.printf("%d=%d\n",number4, getSyracuseSequenceLength(number4));
//        System.out.println(mem);
//        System.out.println();
    }

    public static BigInteger getSyracuseSequenceLength(BigInteger number) {
        BigInteger result = mem.get(number);
        if (result != null) {
            System.out.printf("Cache: {%d=%d}\n", number, result);
            return result;
        }
        if (number.equals(BigInteger.ONE)) {
            mem.put(number, BigInteger.ZERO);
            return BigInteger.ZERO; // добавил (оптимизация)
        } else {
            BigInteger newNumber = null;
            if (number.remainder(BigInteger.TWO).equals(BigInteger.ZERO)) {
                newNumber = number.divide(BigInteger.TWO);
            } else {
                newNumber = number.multiply(BigInteger.valueOf(3)).add(BigInteger.ONE);
            }
            result = BigInteger.ONE.add(getSyracuseSequenceLength(newNumber));
            mem.put(number, result);
            return result; // добавил (оптимизация)
        }
//        return mem.get(number); // оптимизация
    }
}
