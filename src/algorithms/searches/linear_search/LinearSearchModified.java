package algorithms.searches.linear_search;

import java.util.ArrayList;
import java.util.List;

/**
 * ------------------------------------------------------------------------------------------------
 * Линейный (последовательный) поиск.
 * ------------------------------------------------------------------------------------------------
 * Сведение об алгоритме
 *
 * Сложность по времени в наихудшем случае O(n)
 * Затраты памяти O(n)
 * ------------------------------------------------------------------------------------------------
 * Принцип работы алгоритма
 *
 * 1) Установить начальное значения индекса (обозначим его i) равным индексу первого
 *    элемента в последовательности.
 *
 * 2) Получить элемент стоящий по индексу n[i]. Возможны два случая:
 *      a) Ключ элемента равен искомому. Вернуть индекс и завершить алгоритм. Поиск
 *         успешен.
 *      b) Ключ элемента не равен искомому. Увеличить индекс на единицу. i=i+1. Перейти к
 *         пункту 3.
 *
 * 3) Проверить, индекс меньше или равен индексу последнего элемента в
 *    последовательности. Если да, то перейти к пункту 2. Если нет, то завершить алгоритм.
 *    Поиск неудачен.
 * ------------------------------------------------------------------------------------------------
 * Модификация алгоритма линейного поиска
 *
 * Алгоритм линейного поиска можно ускорить путем исключения пункта 3, в базовом
 * алгоритме. Т.е. можно исключить проверку принадлежности индекса значения индексам
 * в последовательности. Для этого стоит добавить в конец базовой последовательности
 * элемент равный искомому.
 *
 * Стоит отметить, что такая модификация имеет смысл только для
 * последовательностей в которых вставка и удаление элемента не связанны с высокими
 * вычислительными затратами.
 * ------------------------------------------------------------------------------------------------
 * Принцип работы модифицированного алгоритма линейного поиска
 *
 * 1) Добавить элемент (значение ключа которого равно искомому) в конец
 *    последовательности.
 *
 * 2) Установить начальное значения индекса (обозначим его i) равным индексу первого
 *    элемента в последовательности.
 *
 * 3) Получить элемент стоящий по индексу n[i]. Возможны два случая:
 *      a) Ключ элемента равен искомому. Удалить последний элемент. Если индекс не
 *         равен индексу последнего элемента — поиск успешен. В случае равенства
 *         индекса индексу последнего элемента — поиск не удачен.
 *      b) Ключ элемента не равен искомому. Увеличить индекс на единицу. i=i+1. Перейти к
 *         началу пункта 3.
 * ------------------------------------------------------------------------------------------------
 * <a href="https://youtu.be/zh0wT6XVrUY">Ссылка на видео</a>
 * ------------------------------------------------------------------------------------------------
 */
public class LinearSearchModified {

    public static void main(String[] args) {
        int[] s = { -2, 0, 3, 5, 7, 9, 11, 15, 18, 21 };
        List<Integer> sequence = new ArrayList<>();
        for (int i = 0; i < s.length; i++) {
            sequence.add(s[i]);
        }
        System.out.println(sequence);

        // 1 - element found
        int element = 5;
        System.out.println(linearSearchModified(sequence, element)  + " -> " + element);

        // 2 - element2 not found
        int element2 = 8;
        System.out.println(linearSearchModified(sequence, element2)  + " -> " + element2);
    }

    public static int linearSearchModified(List<Integer> sequence, int element) {
        sequence.add(element);
        int lastIndex = sequence.size() - 1;
        int i = 0;
        while (sequence.get(i) != element) {
            i++;
        }
        sequence.remove(lastIndex);
        if (i != lastIndex) {
            return i;
        }
        return -1;
    }
}
